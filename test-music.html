<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Test - NightDev</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #050505;
      color: #e0e0e0;
      padding: 2rem;
      text-align: center;
    }
    .controls {
      margin: 2rem 0;
    }
    button {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
      padding: 1rem 2rem;
      margin: 0.5rem;
      border-radius: 8px;
      cursor: pointer;
    }
    button:hover {
      background: #555;
    }
    .status {
      margin: 1rem 0;
      padding: 1rem;
      background: #1a1a1a;
      border-radius: 8px;
      border: 1px solid #333;
    }
    .playlist {
      text-align: left;
      max-width: 600px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <h1>ğŸµ Music System Test</h1>
  <p>This page tests the improved music playlist system</p>

  <div class="controls">
    <button onclick="testPlay()">â–¶ï¸ Test Play</button>
    <button onclick="testSkip()">â­ï¸ Skip Track</button>
    <button onclick="testVolume()">ğŸ”Š Test Volume</button>
    <button onclick="showStatus()">ğŸ“Š Show Status</button>
  </div>

  <div class="status" id="status">
    <strong>Status:</strong> Initializing...
  </div>

  <div class="playlist">
    <h3>Current Playlist:</h3>
    <ol id="playlistDisplay">
      <li>Loading...</li>
    </ol>
  </div>

  <script>
    // Test the music system
    function updateStatus(message) {
      document.getElementById('status').innerHTML = `<strong>Status:</strong> ${message}`;
    }

    function testPlay() {
      if (window.bgAudioPlaylist) {
        updateStatus('Attempting to play music...');
        // Trigger user interaction to start audio
        const event = new Event('click');
        document.dispatchEvent(event);
      } else {
        updateStatus('âŒ Music system not loaded');
      }
    }

    function testSkip() {
      if (window.bgAudioPlaylist && window.bgAudioPlaylist.skip) {
        updateStatus('Skipping to next track...');
        window.bgAudioPlaylist.skip();
      } else {
        updateStatus('âŒ Skip function not available');
      }
    }

    function testVolume() {
      if (window.bgAudioPlaylist && window.bgAudioPlaylist.setVolume) {
        const newVolume = Math.random() * 0.5; // Random volume 0-50%
        window.bgAudioPlaylist.setVolume(newVolume);
        updateStatus(`ğŸ”Š Volume set to ${Math.round(newVolume * 100)}%`);
      } else {
        updateStatus('âŒ Volume control not available');
      }
    }

    function showStatus() {
      if (window.bgAudioPlaylist) {
        const current = window.bgAudioPlaylist.currentAudio();
        const track = window.bgAudioPlaylist.currentTrack();
        const playlist = window.bgAudioPlaylist.playlist;
        
        let statusText = `
          <strong>Music System Status:</strong><br>
          âœ… System loaded: Yes<br>
          ğŸµ Current track: ${track + 1} of ${playlist.length}<br>
          â¸ï¸ Audio paused: ${current ? current.paused : 'N/A'}<br>
          ğŸ”Š Volume: ${current ? Math.round(current.volume * 100) + '%' : 'N/A'}<br>
          ğŸ“± Ready state: ${current ? current.readyState : 'N/A'}<br>
          ğŸŒ Network state: ${current ? current.networkState : 'N/A'}
        `;
        
        updateStatus(statusText);
        
        // Update playlist display
        const playlistEl = document.getElementById('playlistDisplay');
        playlistEl.innerHTML = playlist.map((url, index) => 
          `<li ${index === track ? 'style="color: #4CAF50; font-weight: bold;"' : ''}>
            Track ${index + 1}: ${url.split('/').pop()}
            ${index === track ? ' (Currently Playing)' : ''}
          </li>`
        ).join('');
      } else {
        updateStatus('âŒ Music system not loaded');
      }
    }

    // Check status every 2 seconds
    setInterval(() => {
      if (window.bgAudioPlaylist) {
        const current = window.bgAudioPlaylist.currentAudio();
        if (current && !current.paused) {
          updateStatus(`ğŸµ Playing track ${window.bgAudioPlaylist.currentTrack() + 1} - Volume: ${Math.round(current.volume * 100)}%`);
        }
      }
    }, 2000);

    // Initial status check
    setTimeout(() => {
      showStatus();
    }, 1000);
  </script>

  <!-- Include the music system from index.html -->
  <script>
    (function(){
      // Multi-song playlist - Add as many songs as you want here
      const PLAYLIST = [
        'https://audio.jukehost.co.uk/R7aCAenvHPhXMyOJt276rcd1UUFmPm8w',
        'https://audio.jukehost.co.uk/R4bdxdyaKo3cjbH1g02DnsUR65YICrXF',
      ];

      const FADE_DURATION = 3000; // 3 seconds fade time
      const DEFAULT_VOLUME = 0.25; // adjust default volume (0.0 - 1.0)

      let currentTrackIndex = 0;
      let currentAudio = null;
      let nextAudio = null;
      let isPlaying = false;
      let userInteracted = false;

      // Create audio element
      function createAudioElement(src, id) {
        const audio = document.createElement('audio');
        audio.id = id;
        audio.src = src;
        audio.preload = 'auto';
        audio.crossOrigin = 'anonymous';
        audio.volume = 0;
        audio.style.display = 'none';
        audio.loop = false;
        document.body.appendChild(audio);
        
        // Add error handling
        audio.addEventListener('error', (e) => {
          console.log('Audio error:', e);
          updateStatus(`âŒ Audio error on track ${currentTrackIndex + 1}`);
          // Try to recover by switching to next track
          setTimeout(() => {
            if (PLAYLIST.length > 1) {
              switchToNextTrack();
            } else {
              // For single track, try to reload and restart
              audio.load();
              setTimeout(() => {
                audio.play().catch(err => console.log('Recovery play failed:', err));
              }, 1000);
            }
          }, 2000);
        });

        // Add stalled event handling
        audio.addEventListener('stalled', () => {
          console.log('Audio stalled, attempting recovery...');
          updateStatus('âš ï¸ Audio stalled, attempting recovery...');
          setTimeout(() => {
            if (audio.readyState < 3) { // HAVE_FUTURE_DATA
              audio.load();
            }
          }, 1000);
        });

        // Add waiting event handling
        audio.addEventListener('waiting', () => {
          console.log('Audio waiting for data...');
          updateStatus('â³ Audio buffering...');
        });

        // Add canplaythrough event
        audio.addEventListener('canplaythrough', () => {
          console.log('Audio can play through');
          updateStatus('âœ… Audio ready to play');
        });
        
        // Set up interruption handling for this audio element
        setupAudioInterruptionHandling(audio);
        
        return audio;
      }

      // Fade in audio
      function fadeIn(audio, targetVolume = DEFAULT_VOLUME, duration = FADE_DURATION) {
        return new Promise((resolve) => {
          const steps = 50;
          const stepTime = duration / steps;
          const volumeStep = targetVolume / steps;
          let currentStep = 0;

          const fadeInterval = setInterval(() => {
            currentStep++;
            audio.volume = Math.min(volumeStep * currentStep, targetVolume);
            
            if (currentStep >= steps) {
              clearInterval(fadeInterval);
              resolve();
            }
          }, stepTime);
        });
      }

      // Fade out audio
      function fadeOut(audio, duration = FADE_DURATION) {
        return new Promise((resolve) => {
          const startVolume = audio.volume;
          const steps = 50;
          const stepTime = duration / steps;
          const volumeStep = startVolume / steps;
          let currentStep = 0;

          const fadeInterval = setInterval(() => {
            currentStep++;
            audio.volume = Math.max(startVolume - (volumeStep * currentStep), 0);
            
            if (currentStep >= steps || audio.volume <= 0) {
              clearInterval(fadeInterval);
              audio.volume = 0;
              resolve();
            }
          }, stepTime);
        });
      }

      // Load next track
      function loadNextTrack() {
        const nextIndex = (currentTrackIndex + 1) % PLAYLIST.length;
        if (nextAudio) {
          document.body.removeChild(nextAudio);
        }
        nextAudio = createAudioElement(PLAYLIST[nextIndex], `bg-audio-next-${nextIndex}`);
      }

      // Switch to next track with crossfade
      async function switchToNextTrack() {
        updateStatus('ğŸ”„ Switching to next track...');
        
        // Handle single track playlist - just restart the same track
        if (PLAYLIST.length === 1) {
          try {
            currentAudio.currentTime = 0;
            await currentAudio.play();
            await fadeIn(currentAudio);
            updateStatus('ğŸ” Restarted single track');
          } catch (error) {
            console.log('Error restarting single track:', error);
            updateStatus('âŒ Error restarting track');
          }
          return;
        }

        // Handle multi-track playlist
        if (!nextAudio) return;

        const oldAudio = currentAudio;
        currentAudio = nextAudio;
        currentTrackIndex = (currentTrackIndex + 1) % PLAYLIST.length;

        // Set up event listener for track end on the new current audio
        currentAudio.addEventListener('ended', switchToNextTrack);

        // Start playing next track
        try {
          await currentAudio.play();
          
          // Crossfade: fade out old, fade in new
          const fadeOutPromise = oldAudio ? fadeOut(oldAudio) : Promise.resolve();
          const fadeInPromise = fadeIn(currentAudio);
          
          await Promise.all([fadeOutPromise, fadeInPromise]);
          
          // Clean up old audio
          if (oldAudio) {
            oldAudio.pause();
            document.body.removeChild(oldAudio);
          }
          
          // Load next track for future use
          loadNextTrack();
          
          updateStatus(`âœ… Now playing track ${currentTrackIndex + 1}`);
          
        } catch (error) {
          console.log('Error switching tracks:', error);
          updateStatus('âŒ Error switching tracks');
        }
      }

      // Initialize first track
      function initializePlaylist() {
        if (PLAYLIST.length === 0) return;
        
        currentAudio = createAudioElement(PLAYLIST[currentTrackIndex], `bg-audio-${currentTrackIndex}`);
        
        // Set up event listener for track end
        currentAudio.addEventListener('ended', switchToNextTrack);
        
        // Load next track if we have more than one song
        if (PLAYLIST.length > 1) {
          loadNextTrack();
        }
        
        updateStatus('ğŸµ Playlist initialized');
      }

      // Try to play current track
      async function tryPlay() {
        if (!currentAudio || isPlaying) return;
        
        try {
          // Ensure audio is loaded before playing
          if (currentAudio.readyState < 2) { // HAVE_CURRENT_DATA
            updateStatus('â³ Loading audio data...');
            await new Promise((resolve) => {
              const onCanPlay = () => {
                currentAudio.removeEventListener('canplay', onCanPlay);
                currentAudio.removeEventListener('error', onError);
                resolve();
              };
              const onError = () => {
                currentAudio.removeEventListener('canplay', onCanPlay);
                currentAudio.removeEventListener('error', onError);
                resolve(); // Continue anyway
              };
              currentAudio.addEventListener('canplay', onCanPlay);
              currentAudio.addEventListener('error', onError);
              
              // Timeout after 5 seconds
              setTimeout(() => {
                currentAudio.removeEventListener('canplay', onCanPlay);
                currentAudio.removeEventListener('error', onError);
                resolve();
              }, 5000);
            });
          }
          
          await currentAudio.play();
          await fadeIn(currentAudio);
          isPlaying = true;
          updateStatus('ğŸµ Audio started successfully');
          console.log('Audio started successfully');
        } catch (error) {
          console.log('Autoplay blocked, waiting for user interaction:', error);
          updateStatus('âš ï¸ Click "Test Play" to start music (autoplay blocked)');
        }
      }

      // Handle user interaction to start audio
      const startOnGesture = async () => {
        if (userInteracted) return;
        userInteracted = true;
        
        updateStatus('ğŸ‘† User interaction detected, starting audio...');
        await tryPlay();
        
        // Remove event listeners
        window.removeEventListener('click', startOnGesture);
        window.removeEventListener('keydown', startOnGesture);
        window.removeEventListener('touchstart', startOnGesture);
      };

      // Handle page visibility changes
      document.addEventListener('visibilitychange', async () => {
        if (!currentAudio || !userInteracted) return;
        
        if (!document.hidden) {
          // Tab became visible again - check if audio is still playing
          if (currentAudio.paused && isPlaying) {
            try {
              await currentAudio.play();
              await fadeIn(currentAudio);
              updateStatus('ğŸ”„ Resumed audio after tab focus');
            } catch (error) {
              console.log('Could not resume audio:', error);
              updateStatus('âŒ Could not resume audio');
            }
          }
        }
      });

      // Handle audio interruptions (when browser pauses audio)
      function setupAudioInterruptionHandling(audio) {
        audio.addEventListener('pause', async () => {
          if (isPlaying && userInteracted && !document.hidden && audio === currentAudio) {
            // Audio was paused unexpectedly, try to resume
            console.log('Audio paused unexpectedly, attempting to resume...');
            updateStatus('âš ï¸ Audio paused unexpectedly, attempting to resume...');
            setTimeout(async () => {
              try {
                if (audio.paused && isPlaying && audio === currentAudio) {
                  await audio.play();
                  updateStatus('âœ… Successfully resumed audio');
                  console.log('Successfully resumed audio');
                }
              } catch (error) {
                console.log('Could not resume paused audio:', error);
                updateStatus('âŒ Could not resume paused audio');
                // If we can't resume, try switching to next track
                if (PLAYLIST.length > 1) {
                  setTimeout(switchToNextTrack, 1000);
                }
              }
            }, 500);
          }
        });

        // Handle ended event more robustly
        audio.addEventListener('ended', () => {
          console.log('Track ended, switching to next...');
          updateStatus('â­ï¸ Track ended, switching to next...');
          if (audio === currentAudio) {
            switchToNextTrack();
          }
        });
      }

      // Periodic check to ensure audio is still playing
      setInterval(() => {
        if (currentAudio && isPlaying && userInteracted && !document.hidden) {
          if (currentAudio.paused) {
            // Audio got paused somehow, try to resume
            currentAudio.play().catch(error => {
              console.log('Periodic check: Could not resume audio:', error);
            });
          }
        }
      }, 5000); // Check every 5 seconds

      // Initialize the playlist
      initializePlaylist();

      // Try to start playing after a short delay
      setTimeout(tryPlay, 300);

      // Set up user interaction listeners
      window.addEventListener('click', startOnGesture, { once: true });
      window.addEventListener('keydown', startOnGesture, { once: true });
      window.addEventListener('touchstart', startOnGesture, { once: true });

      // Expose controls for debugging
      window.bgAudioPlaylist = {
        currentAudio: () => currentAudio,
        nextAudio: () => nextAudio,
        currentTrack: () => currentTrackIndex,
        playlist: PLAYLIST,
        skip: switchToNextTrack,
        setVolume: (vol) => {
          if (currentAudio) currentAudio.volume = vol;
        }
      };
    })();
  </script>
</body>
</html>