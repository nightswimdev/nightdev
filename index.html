<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.13, shrink-to-fit=yes"
    />
    <title>nightdev | Home </title>
    <meta
      name="description"
      content=""
    />
    <meta
      name="keywords"
      content="Student Resource, education, entertainment, Learning Portal, nightswim"
    />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: dark)"
      content="#434c5e"
    />
    <meta name="googlebot" content="index, follow, snippet" />
    <link rel="icon" type="image/x-icon" href="/assets/js/icon/Untitled design (14)-Picsart-BackgroundRemover.png">
    <link rel="shortcut icon" content="favicon.ico" />
    <link rel="stylesheet" href="index.css" />
    <script src="active/uv/uv.bundle.js" defer></script>
    <script src="active/uv/uv.config.js" defer></script>
    <script src="assets/js/register.js" defer></script>

    <script src="mobile-redirect.js"></script>
    <script src="assets/js/index.js" defer></script>
     <script src="assets/js/indexd.js" defer></script>
    <!-- NightDev Analytics & IP Tracking -->
    <script src="analytics.js" defer></script>
    <!-- Add this in your <head> -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  </head>

  <body>
    <!-- Add this to every page, preferably just inside <body> as the first element -->
    <div id="nprogress" style="transition: 200ms linear; opacity: 0;">
      <div class="bar" role="bar" style="transform: translate3d(0%, 0px, 0px); transition: 200ms;">
        <div class="peg"></div>
      </div>
      <div class="spinner" role="spinner">
        <div class="spinner-icon"></div>
      </div>
    </div>
      

    <div class="background-container">
      <div class="wave-container">
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
      </div>
      <!-- Light beams (optional, 6 beams for effect) -->
      <div class="light-beam" style="left: 10%; animation-delay: 0s;"></div>
      <div class="light-beam" style="left: 30%; animation-delay: 2s;"></div>
      <div class="light-beam" style="left: 50%; animation-delay: 4s;"></div>
      <div class="light-beam" style="left: 70%; animation-delay: 1s;"></div>
      <div class="light-beam" style="left: 85%; animation-delay: 3s;"></div>
      <div class="light-beam" style="left: 95%; animation-delay: 5s;"></div>
    </div>

  <div class="relative flex flex-col h-[100vh] items-center justify-center bg-black transition-bg">
    <div class="absolute inset-0 overflow-hidden">
      <div class="god-rays absolute -inset-[10px] opacity-50"></div>
    </div>
  </div>
  
    <!-- Main Navbar (bigger, centered, with brand) -->
    <div class="navbar main-navbar">
      <div class="navbar-light-border"></div>
    
      <div class="navbar-light-inset-bg"></div>
      <div class="navbar-light"></div>
      <div class="main-navbar-title">
        <img src="assets/js/icon/Untitled design (14)-Picsart-BackgroundRemover.png" alt="nightdev logo" class="main-navbar-logo" />
        <span>nightdev</span>
      </div>
      <ul class="nav-buttons">
        <li><a href="index.html" class="active" title="Home"><i class="fa-solid fa-house"></i></a></li>
        <li><a href="apps.html" title="Apps"><i class="fa-solid fa-th"></i></a></li>
        <li><a href="settings.html" title="Settings"><i class="fa-solid fa-gear"></i></a></li>
        <li>
          <a href="ai.html" title="AI">
            <i class="fa-solid fa-robot"></i>
          </a>
        </li>
      </ul>
      <div class="login-button-container">
        <button class="login-button" title="Login">
          <div class="login-light-border"></div>
          <div class="login-light-inset-bg"></div>
          <div class="login-light"></div>
          <i class="fa-solid fa-user"></i>
          <span>Login</span>
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="logo-wrapper header-center">
        <img class="logo" src="assets/js/icon/Untitled design (14)-Picsart-BackgroundRemover.png" alt="nightdev" />
        <h1>nightdev | nightswim
        </h1>
      </div>
      <div class="desc">
        <p>
          Search the web freely with nightdev.
        </p>
      </div>
      <form id="uv-form" class="flex-center search-bar" autocomplete="off" style="position: relative;">
        <div class="light-border"></div>
        <div class="light-inset-bg"></div>
        <div class="light"></div>
        <span class="home-search-icon">
          <i class="fa-solid fa-magnifying-glass"></i>
        </span>
        <input
          id="uv-address"
          type="text"
          placeholder="What's on your mind today?"
          autocomplete="off"
          style="padding-left: 2.5em;"
        />
        <div id="index-suggestions-container" class="suggestions-container"></div>
      </form>

      <!-- Quick Links row -->
      <div id="quick-links" class="quick-links" aria-label="Quick links"></div>

      <!-- Quick Link Modal -->
      <div id="ql-modal" class="ql-modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="ql-modal-title">
        <div class="ql-modal-card">
          <div class="ql-modal-header">
            <h3 id="ql-modal-title">Add quick link</h3>
            <button id="ql-modal-close" class="ql-close-btn" aria-label="Close">&times;</button>
          </div>
          <div class="ql-modal-body">
            <label for="ql-input-url">Site URL</label>
            <input id="ql-input-url" type="url" placeholder="https://nightdev.pages.dev" required />
            <label for="ql-input-title">Title</label>
            <input id="ql-input-title" type="text" placeholder="nightdev" />
            <label for="ql-input-icon">Icon URL</label>
            <input id="ql-input-icon" type="url" placeholder="https://.../favicon.ico" />
            <div class="ql-preview">
              <div class="ql-icon"><img id="ql-preview-icon" alt="" /></div>
              <div class="ql-preview-title" id="ql-preview-title">Preview</div>
            </div>
          </div>
          <div class="ql-actions">
            <button id="ql-delete" class="danger" style="display:none">Delete</button>
            <div class="spacer"></div>
            <button id="ql-cancel">Cancel</button>
            <button id="ql-save" class="primary">Save</button>
          </div>
        </div>
      </div>

      <div class="desc left-margin">
        <p id="uv-error"></p>
        <pre id="uv-error-code"></pre>
      </div>
      
      <!-- History Section -->
      <div id="history-section" class="history-section" style="display: none;">
        <div class="history-title">Recent</div>
        <ul id="history-list" class="history-list"></ul>
        <button id="clear-history" class="clear-history">Clear History</button>
      </div>
      
      <!-- Toast container (top right) -->
<div id="toast-container" style="position:fixed;top:30px;right:30px;z-index:10000;"></div>
<!-- Greeting placeholder (will be filled by JS) -->
<div id="greeting" style="margin:1em auto 0.5em auto;text-align:center;font-size:1.18em;color:#bfc9db;font-weight:500;opacity:0;transition:opacity 0.4s;"></div>
    </div>
    
    <footer>
      <a
        title="guns.lol"
        href="https://guns.lol/nightswim"
        >guns.lol</a
      >
      <a
        title="github"
        href="https://github.com/nightswimdev"
        >GitHub</a
      >
      <a
        title="License information"
        href="credits.html"
        style="margin-left: auto"
        >Credits</a
      >
      <span>nightswim &copy; net 2025</span>
    </footer>
<script src="settings.js"></script>

<script>
(function(){
  // Multi-song playlist - Add as many songs as you want here
  const PLAYLIST = [
    'https://audio.jukehost.co.uk/R7aCAenvHPhXMyOJt276rcd1UUFmPm8w',
    'https://audio.jukehost.co.uk/R4bdxdyaKo3cjbH1g02DnsUR65YICrXF',
  ];

  const FADE_DURATION = 3000; // 3 seconds fade time
  const DEFAULT_VOLUME = 0.25; // adjust default volume (0.0 - 1.0)

  let currentTrackIndex = 0;
  let currentAudio = null;
  let nextAudio = null;
  let isPlaying = false;
  let userInteracted = false;

  // Create audio element
  function createAudioElement(src, id) {
    const audio = document.createElement('audio');
    audio.id = id;
    audio.src = src;
    audio.preload = 'auto';
    audio.crossOrigin = 'anonymous';
    audio.volume = 0;
    audio.style.display = 'none';
    audio.loop = false;
    document.body.appendChild(audio);
    
    // Add error handling
    audio.addEventListener('error', (e) => {
      console.log('Audio error:', e);
      // Try to recover by switching to next track
      setTimeout(() => {
        if (PLAYLIST.length > 1) {
          switchToNextTrack();
        } else {
          // For single track, try to reload and restart
          audio.load();
          setTimeout(() => {
            audio.play().catch(err => console.log('Recovery play failed:', err));
          }, 1000);
        }
      }, 2000);
    });

    // Add stalled event handling
    audio.addEventListener('stalled', () => {
      console.log('Audio stalled, attempting recovery...');
      setTimeout(() => {
        if (audio.readyState < 3) { // HAVE_FUTURE_DATA
          audio.load();
        }
      }, 1000);
    });

    // Add waiting event handling
    audio.addEventListener('waiting', () => {
      console.log('Audio waiting for data...');
    });

    // Add canplaythrough event
    audio.addEventListener('canplaythrough', () => {
      console.log('Audio can play through');
    });
    
    // Set up interruption handling for this audio element
    setupAudioInterruptionHandling(audio);
    
    return audio;
  }

  // Fade in audio
  function fadeIn(audio, targetVolume = DEFAULT_VOLUME, duration = FADE_DURATION) {
    return new Promise((resolve) => {
      const steps = 50;
      const stepTime = duration / steps;
      const volumeStep = targetVolume / steps;
      let currentStep = 0;

      const fadeInterval = setInterval(() => {
        currentStep++;
        audio.volume = Math.min(volumeStep * currentStep, targetVolume);
        
        if (currentStep >= steps) {
          clearInterval(fadeInterval);
          resolve();
        }
      }, stepTime);
    });
  }

  // Fade out audio
  function fadeOut(audio, duration = FADE_DURATION) {
    return new Promise((resolve) => {
      const startVolume = audio.volume;
      const steps = 50;
      const stepTime = duration / steps;
      const volumeStep = startVolume / steps;
      let currentStep = 0;

      const fadeInterval = setInterval(() => {
        currentStep++;
        audio.volume = Math.max(startVolume - (volumeStep * currentStep), 0);
        
        if (currentStep >= steps || audio.volume <= 0) {
          clearInterval(fadeInterval);
          audio.volume = 0;
          resolve();
        }
      }, stepTime);
    });
  }

  // Load next track
  function loadNextTrack() {
    const nextIndex = (currentTrackIndex + 1) % PLAYLIST.length;
    if (nextAudio) {
      document.body.removeChild(nextAudio);
    }
    nextAudio = createAudioElement(PLAYLIST[nextIndex], `bg-audio-next-${nextIndex}`);
  }

  // Switch to next track with crossfade
  async function switchToNextTrack() {
    // Handle single track playlist - just restart the same track
    if (PLAYLIST.length === 1) {
      try {
        currentAudio.currentTime = 0;
        await currentAudio.play();
        await fadeIn(currentAudio);
      } catch (error) {
        console.log('Error restarting single track:', error);
      }
      return;
    }

    // Handle multi-track playlist
    if (!nextAudio) return;

    const oldAudio = currentAudio;
    currentAudio = nextAudio;
    currentTrackIndex = (currentTrackIndex + 1) % PLAYLIST.length;

    // Set up event listener for track end on the new current audio
    currentAudio.addEventListener('ended', switchToNextTrack);

    // Start playing next track
    try {
      await currentAudio.play();
      
      // Crossfade: fade out old, fade in new
      const fadeOutPromise = oldAudio ? fadeOut(oldAudio) : Promise.resolve();
      const fadeInPromise = fadeIn(currentAudio);
      
      await Promise.all([fadeOutPromise, fadeInPromise]);
      
      // Clean up old audio
      if (oldAudio) {
        oldAudio.pause();
        document.body.removeChild(oldAudio);
      }
      
      // Load next track for future use
      loadNextTrack();
      
    } catch (error) {
      console.log('Error switching tracks:', error);
    }
  }

  // Initialize first track
  function initializePlaylist() {
    if (PLAYLIST.length === 0) return;
    
    currentAudio = createAudioElement(PLAYLIST[currentTrackIndex], `bg-audio-${currentTrackIndex}`);
    
    // Set up event listener for track end
    currentAudio.addEventListener('ended', switchToNextTrack);
    
    // Load next track if we have more than one song
    if (PLAYLIST.length > 1) {
      loadNextTrack();
    }
  }

  // Try to play current track
  async function tryPlay() {
    if (!currentAudio || isPlaying) return;
    
    try {
      // Ensure audio is loaded before playing
      if (currentAudio.readyState < 2) { // HAVE_CURRENT_DATA
        await new Promise((resolve) => {
          const onCanPlay = () => {
            currentAudio.removeEventListener('canplay', onCanPlay);
            currentAudio.removeEventListener('error', onError);
            resolve();
          };
          const onError = () => {
            currentAudio.removeEventListener('canplay', onCanPlay);
            currentAudio.removeEventListener('error', onError);
            resolve(); // Continue anyway
          };
          currentAudio.addEventListener('canplay', onCanPlay);
          currentAudio.addEventListener('error', onError);
          
          // Timeout after 5 seconds
          setTimeout(() => {
            currentAudio.removeEventListener('canplay', onCanPlay);
            currentAudio.removeEventListener('error', onError);
            resolve();
          }, 5000);
        });
      }
      
      await currentAudio.play();
      await fadeIn(currentAudio);
      isPlaying = true;
      console.log('Audio started successfully');
    } catch (error) {
      console.log('Autoplay blocked, waiting for user interaction:', error);
    }
  }

  // Handle user interaction to start audio
  const startOnGesture = async () => {
    if (userInteracted) return;
    userInteracted = true;
    
    await tryPlay();
    
    // Remove event listeners
    window.removeEventListener('click', startOnGesture);
    window.removeEventListener('keydown', startOnGesture);
    window.removeEventListener('touchstart', startOnGesture);
  };

  // Handle page visibility changes
  document.addEventListener('visibilitychange', async () => {
    if (!currentAudio || !userInteracted) return;
    
    if (!document.hidden) {
      // Tab became visible again - check if audio is still playing
      if (currentAudio.paused && isPlaying) {
        try {
          await currentAudio.play();
          await fadeIn(currentAudio);
        } catch (error) {
          console.log('Could not resume audio:', error);
        }
      }
    }
  });

  // Handle audio interruptions (when browser pauses audio)
  function setupAudioInterruptionHandling(audio) {
    audio.addEventListener('pause', async () => {
      if (isPlaying && userInteracted && !document.hidden && audio === currentAudio) {
        // Audio was paused unexpectedly, try to resume
        console.log('Audio paused unexpectedly, attempting to resume...');
        setTimeout(async () => {
          if (audio.paused && isPlaying && audio === currentAudio) {
            await audio.play();
            console.log('Successfully resumed audio');
          }
        }, 500);
      }
    });

    // Handle ended event more robustly
    audio.addEventListener('ended', () => {
      console.log('Track ended, switching to next...');
      if (audio === currentAudio) {
        switchToNextTrack();
      }
    });
  }

  // Periodic check to ensure audio is still playing
  setInterval(() => {
    if (currentAudio && isPlaying && userInteracted && !document.hidden) {
      if (currentAudio.paused) {
        // Audio got paused somehow, try to resume
        currentAudio.play().catch(error => {
          console.log('Periodic check: Could not resume audio:', error);
        });
      }
    }
  }, 5000); // Check every 5 seconds

  // Initialize the playlist
  initializePlaylist();

  // Try to start playing after a short delay
  setTimeout(tryPlay, 300);

  // Set up user interaction listeners
  window.addEventListener('click', startOnGesture, { once: true });
  window.addEventListener('keydown', startOnGesture, { once: true });
  window.addEventListener('touchstart', startOnGesture, { once: true });

  // Expose controls for debugging
  window.bgAudioPlaylist = {
    currentAudio: () => currentAudio,
    nextAudio: () => nextAudio,
    currentTrack: () => currentTrackIndex,
    playlist: PLAYLIST,
    skip: switchToNextTrack,
    setVolume: (vol) => {
      if (currentAudio) currentAudio.volume = vol;
    }
  };
})();
</script>

<script>
// Light following effect for search bar - exact implementation from example
document.addEventListener('DOMContentLoaded', function() {
  const searchBar = document.querySelector('.search-bar');
  const lightBg = searchBar.querySelector('.light');
  const lightBorder = searchBar.querySelector('.light-border');
  const lightSize = 300;

  let targetX = 0, targetY = 0;
  let currentX = 0, currentY = 0;
  let lastX = 0, lastY = 0;
  let velocityX = 0, velocityY = 0;
  let raf;

  function animate() {
    currentX += (targetX - currentX) * 0.15;
    currentY += (targetY - currentY) * 0.15;

    const elasticX = Math.min(Math.max(velocityX * 0.5, -20), 20);
    const elasticY = Math.min(Math.max(velocityY * 0.5, -20), 20);

    const bgX = `${currentX - lightSize / 2 + elasticX}px`;
    const bgY = `${currentY - lightSize / 2 + elasticY}px`;

    lightBg.style.setProperty('--bg-x', bgX);
    lightBg.style.setProperty('--bg-y', bgY);
    lightBorder.style.setProperty('--bg-x', bgX);
    lightBorder.style.setProperty('--bg-y', bgY);

    raf = requestAnimationFrame(animate);
  }

  searchBar.addEventListener('mouseenter', () => {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(animate);

    lightBg.style.opacity = 1;
    lightBorder.style.opacity = 1;
    lightBg.style.transition = "opacity 0.4s ease, transform 0.4s ease, filter 0.6s ease";
    lightBorder.style.transition = "opacity 0.4s ease, transform 0.4s ease, filter 0.6s ease";

    lightBg.style.transform = "scale(1.15)";
    lightBg.style.filter = "blur(20px)";
    lightBorder.style.transform = "scale(1.1)";
    lightBorder.style.filter = "blur(6px)";

    setTimeout(() => {
      lightBg.style.transform = "scale(1)";
      lightBg.style.filter = "blur(12px)";
      lightBorder.style.transform = "scale(1)";
      lightBorder.style.filter = "blur(4px)";
    }, 300);
  });

  searchBar.addEventListener('mouseleave', () => {
    cancelAnimationFrame(raf);

    lightBg.style.transition = "opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease";
    lightBorder.style.transition = "opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease";

    lightBg.style.opacity = 0;
    lightBorder.style.opacity = 0;
    lightBg.style.transform = "scale(0.95)";
    lightBorder.style.transform = "scale(0.95)";
    lightBg.style.filter = "blur(30px)";
    lightBorder.style.filter = "blur(12px)";
  });

  searchBar.addEventListener('mousemove', (e) => {
    const rect = searchBar.getBoundingClientRect();
    targetX = e.clientX - rect.left;
    targetY = e.clientY - rect.top;

    velocityX = targetX - lastX;
    velocityY = targetY - lastY;
    lastX = targetX;
    lastY = targetY;

    const glowStrength = Math.min(1.2, 0.8 + targetX / rect.width * 0.4);
    lightBg.style.transform = `scale(${glowStrength})`;
  });
});

// Light following effect for navbar - exact same implementation
document.addEventListener('DOMContentLoaded', function() {
  const navbar = document.querySelector('.main-navbar');
  const navbarLightBg = navbar.querySelector('.navbar-light');
  const navbarLightBorder = navbar.querySelector('.navbar-light-border');
  const lightSize = 300;

  let navbarTargetX = 0, navbarTargetY = 0;
  let navbarCurrentX = 0, navbarCurrentY = 0;
  let navbarLastX = 0, navbarLastY = 0;
  let navbarVelocityX = 0, navbarVelocityY = 0;
  let navbarRaf;

  function navbarAnimate() {
    navbarCurrentX += (navbarTargetX - navbarCurrentX) * 0.15;
    navbarCurrentY += (navbarTargetY - navbarCurrentY) * 0.15;

    const elasticX = Math.min(Math.max(navbarVelocityX * 0.5, -20), 20);
    const elasticY = Math.min(Math.max(navbarVelocityY * 0.5, -20), 20);

    const bgX = `${navbarCurrentX - lightSize / 2 + elasticX}px`;
    const bgY = `${navbarCurrentY - lightSize / 2 + elasticY}px`;

    navbarLightBg.style.setProperty('--navbar-bg-x', bgX);
    navbarLightBg.style.setProperty('--navbar-bg-y', bgY);
    navbarLightBorder.style.setProperty('--navbar-bg-x', bgX);
    navbarLightBorder.style.setProperty('--navbar-bg-y', bgY);

    navbarRaf = requestAnimationFrame(navbarAnimate);
  }

  navbar.addEventListener('mouseenter', () => {
    cancelAnimationFrame(navbarRaf);
    navbarRaf = requestAnimationFrame(navbarAnimate);

    navbarLightBg.style.opacity = 1;
    navbarLightBorder.style.opacity = 1;
    navbarLightBg.style.transition = "opacity 0.4s ease, transform 0.4s ease, filter 0.6s ease";
    navbarLightBorder.style.transition = "opacity 0.4s ease, transform 0.4s ease, filter 0.6s ease";

    navbarLightBg.style.transform = "scale(1.15)";
    navbarLightBg.style.filter = "blur(20px)";
    navbarLightBorder.style.transform = "scale(1.1)";
    navbarLightBorder.style.filter = "blur(6px)";

    setTimeout(() => {
      navbarLightBg.style.transform = "scale(1)";
      navbarLightBg.style.filter = "blur(12px)";
      navbarLightBorder.style.transform = "scale(1)";
      navbarLightBorder.style.filter = "blur(4px)";
    }, 300);
  });

  navbar.addEventListener('mouseleave', () => {
    cancelAnimationFrame(navbarRaf);

    navbarLightBg.style.transition = "opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease";
    navbarLightBorder.style.transition = "opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease";

    navbarLightBg.style.opacity = 0;
    navbarLightBorder.style.opacity = 0;
    navbarLightBg.style.transform = "scale(0.95)";
    navbarLightBorder.style.transform = "scale(0.95)";
    navbarLightBg.style.filter = "blur(30px)";
    navbarLightBorder.style.filter = "blur(12px)";
  });

  navbar.addEventListener('mousemove', (e) => {
    const rect = navbar.getBoundingClientRect();
    navbarTargetX = e.clientX - rect.left;
    navbarTargetY = e.clientY - rect.top;

    navbarVelocityX = navbarTargetX - navbarLastX;
    navbarVelocityY = navbarTargetY - navbarLastY;
    navbarLastX = navbarTargetX;
    navbarLastY = navbarTargetY;

    const glowStrength = Math.min(1.2, 0.8 + navbarTargetX / rect.width * 0.4);
    navbarLightBg.style.transform = `scale(${glowStrength})`;
  });
});

// Light following effect for login button
document.addEventListener('DOMContentLoaded', function() {
  const loginButton = document.querySelector('.login-button');
  const loginLightBg = loginButton.querySelector('.login-light');
  const loginLightBorder = loginButton.querySelector('.login-light-border');
  const lightSize = 200;

  let loginTargetX = 0, loginTargetY = 0;
  let loginCurrentX = 0, loginCurrentY = 0;
  let loginLastX = 0, loginLastY = 0;
  let loginVelocityX = 0, loginVelocityY = 0;
  let loginRaf;

  function loginAnimate() {
    loginCurrentX += (loginTargetX - loginCurrentX) * 0.15;
    loginCurrentY += (loginTargetY - loginCurrentY) * 0.15;

    const elasticX = Math.min(Math.max(loginVelocityX * 0.5, -15), 15);
    const elasticY = Math.min(Math.max(loginVelocityY * 0.5, -15), 15);

    const bgX = `${loginCurrentX - lightSize / 2 + elasticX}px`;
    const bgY = `${loginCurrentY - lightSize / 2 + elasticY}px`;

    loginLightBg.style.setProperty('--login-bg-x', bgX);
    loginLightBg.style.setProperty('--login-bg-y', bgY);
    loginLightBorder.style.setProperty('--login-bg-x', bgX);
    loginLightBorder.style.setProperty('--login-bg-y', bgY);

    loginRaf = requestAnimationFrame(loginAnimate);
  }

  loginButton.addEventListener('mouseenter', () => {
    cancelAnimationFrame(loginRaf);
    loginRaf = requestAnimationFrame(loginAnimate);

    loginLightBg.style.opacity = 1;
    loginLightBorder.style.opacity = 1;
    loginLightBg.style.transition = "opacity 0.4s ease, transform 0.4s ease, filter 0.6s ease";
    loginLightBorder.style.transition = "opacity 0.4s ease, transform 0.4s ease, filter 0.6s ease";

    loginLightBg.style.transform = "scale(1.15)";
    loginLightBg.style.filter = "blur(20px)";
    loginLightBorder.style.transform = "scale(1.1)";
    loginLightBorder.style.filter = "blur(6px)";

    setTimeout(() => {
      loginLightBg.style.transform = "scale(1)";
      loginLightBg.style.filter = "blur(12px)";
      loginLightBorder.style.transform = "scale(1)";
      loginLightBorder.style.filter = "blur(4px)";
    }, 300);
  });

  loginButton.addEventListener('mouseleave', () => {
    cancelAnimationFrame(loginRaf);

    loginLightBg.style.transition = "opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease";
    loginLightBorder.style.transition = "opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease";

    loginLightBg.style.opacity = 0;
    loginLightBorder.style.opacity = 0;
    loginLightBg.style.transform = "scale(0.95)";
    loginLightBorder.style.transform = "scale(0.95)";
    loginLightBg.style.filter = "blur(30px)";
    loginLightBorder.style.filter = "blur(12px)";
  });

  loginButton.addEventListener('mousemove', (e) => {
    const rect = loginButton.getBoundingClientRect();
    loginTargetX = e.clientX - rect.left;
    loginTargetY = e.clientY - rect.top;

    loginVelocityX = loginTargetX - loginLastX;
    loginVelocityY = loginTargetY - loginLastY;
    loginLastX = loginTargetX;
    loginLastY = loginTargetY;

    const glowStrength = Math.min(1.2, 0.8 + loginTargetX / rect.width * 0.4);
    loginLightBg.style.transform = `scale(${glowStrength})`;
  });

  // Add click handler for login functionality
  loginButton.addEventListener('click', () => {
    window.location.href = 'login.html';
  });
});

// Toast Notification System
class ToastManager {
  constructor() {
    this.toasts = [];
  }

  show(message, type = 'error', duration = 5000) {
    const toast = this.createToast(message, type);
    document.body.appendChild(toast);
    this.toasts.push(toast);

    // Show toast
    setTimeout(() => {
      toast.classList.add('show');
    }, 100);

    // Auto-hide toast
    setTimeout(() => {
      this.hide(toast);
    }, duration);

    return toast;
  }

  createToast(message, type) {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const iconMap = {
      error: 'fa-exclamation-circle',
      warning: 'fa-exclamation-triangle',
      success: 'fa-check-circle',
      info: 'fa-info-circle'
    };

    toast.innerHTML = `
      <div class="toast-content">
        <i class="fa-solid ${iconMap[type]} toast-icon"></i>
        <div class="toast-message">${message}</div>
        <button class="toast-close" onclick="toastManager.hide(this.parentElement.parentElement)">
          <i class="fa-solid fa-times"></i>
        </button>
      </div>
    `;

    return toast;
  }

  hide(toast) {
    toast.classList.remove('show');
    setTimeout(() => {
      if (toast.parentElement) {
        toast.parentElement.removeChild(toast);
      }
      this.toasts = this.toasts.filter(t => t !== toast);
    }, 400);
  }
}

// Initialize toast manager
const toastManager = new ToastManager();

// Authentication System for Index Page
class IndexAuth {
  constructor() {
    this.currentUser = this.getCurrentUser();
    this.init();
  }

  getCurrentUser() {
    const localSession = localStorage.getItem('nightdev_session');
    const sessionSession = sessionStorage.getItem('nightdev_session');
    
    if (localSession || sessionSession) {
      try {
        return JSON.parse(localSession || sessionSession);
      } catch (e) {
        localStorage.removeItem('nightdev_session');
        sessionStorage.removeItem('nightdev_session');
        return null;
      }
    }
    return null;
  }

  init() {
    // Check URL parameters for authentication warnings
    const urlParams = new URLSearchParams(window.location.search);
    const authWarning = urlParams.get('auth');
    
    if (authWarning === 'required') {
      toastManager.show(
        'Authentication required! Please log in to access developer features.',
        'warning',
        6000
      );
      // Clean URL
      window.history.replaceState({}, document.title, window.location.pathname);
    }

    // Update login button if user is logged in
    this.updateLoginButton();
    
    // Add dashboard access protection
    this.protectDashboardAccess();
  }

  updateLoginButton() {
    const loginButton = document.querySelector('.login-button');
    if (this.currentUser && loginButton) {
      const buttonSpan = loginButton.querySelector('span');
      const buttonIcon = loginButton.querySelector('i');
      
      if (buttonSpan && buttonIcon) {
        buttonIcon.className = 'fa-solid fa-tachometer-alt';
        buttonSpan.textContent = 'Dashboard';
        
        // Update click handler
        loginButton.onclick = () => {
          window.location.href = 'dashboard.html';
        };
      }
    }
  }

  protectDashboardAccess() {
    // Add click handlers to any dashboard/dev links
    const devLinks = document.querySelectorAll('a[href*="dashboard"], a[href*="admin"], .dev-link');
    
    devLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        if (!this.currentUser) {
          e.preventDefault();
          toastManager.show(
            'Access denied! This is a developer page. Please log in first.',
            'error',
            5000
          );
          
          setTimeout(() => {
            window.location.href = 'login.html';
          }, 2000);
        }
      });
    });
  }

  logout() {
    localStorage.removeItem('nightdev_session');
    sessionStorage.removeItem('nightdev_session');
    this.currentUser = null;
    
    toastManager.show('Logged out successfully!', 'success', 3000);
    
    // Reset login button
    setTimeout(() => {
      window.location.reload();
    }, 1000);
  }
}

// Initialize authentication system
document.addEventListener('DOMContentLoaded', () => {
  window.indexAuth = new IndexAuth();
});
</script>

<!-- Security Warning JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  const overlay = document.getElementById('security-warning-overlay');
  const acceptBtn = document.getElementById('security-warning-accept');
  const declineBtn = document.getElementById('security-warning-decline');
  
  // Check if user has already accepted the warning
  const hasAccepted = localStorage.getItem('security-warning-accepted');
  
  if (hasAccepted === 'true') {
    // Hide the overlay if already accepted
    overlay.classList.add('hidden');
  }
  
  // Handle accept button
  acceptBtn.addEventListener('click', function() {
    // Store acceptance in localStorage
    localStorage.setItem('security-warning-accepted', 'true');
    
    // Add fade out animation
    overlay.classList.add('hidden');
    
    // Optional: Show a brief confirmation
    setTimeout(() => {
      console.log('Security warning accepted. Welcome to nightdev.');
    }, 300);
  });
  
  // Handle decline button
  declineBtn.addEventListener('click', function() {
    // Redirect to a safe page or close the window
    if (confirm('Are you sure you want to leave this site?')) {
      // Try to close the window/tab
      try {
        window.close();
      } catch(e) {
        // If can't close, redirect to a safe page
        window.location.href = 'https://www.google.com';
      }
    }
  });
  
  // Prevent closing the overlay by clicking outside (force user to make a choice)
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) {
      // Don't close - user must click a button
      const modal = overlay.querySelector('.security-warning-modal');
      modal.style.animation = 'none';
      modal.offsetHeight; // Trigger reflow
      modal.style.animation = 'securityModalSlideIn 0.3s ease-out';
    }
  });
  
  // Prevent escape key from closing
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && !overlay.classList.contains('hidden')) {
      e.preventDefault();
      // Shake animation to indicate it can't be closed
      const modal = overlay.querySelector('.security-warning-modal');
      modal.style.animation = 'none';
      modal.offsetHeight; // Trigger reflow
      modal.style.animation = 'securityModalSlideIn 0.3s ease-out';
    }
  });
});
</script>
  </body>
</html>
